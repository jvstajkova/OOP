#include<iostream>
using namespace std;

class Point
{
	int x;
	int y;
public:
	Point(int x = 0, int y = 0){
		this->x = x;
		this->y = y;
	}

	bool equal(const Point& other) const{
		return x == other.getX() && y == other.getY();
	}

	int getX() const{
		return x;
	}

	int getY() const{
		return y;
	}

private:

};

class ListOfPoints{
protected:
		Point *vector;
		int defaultSize;
		int size;

		void destroyMe(){
			delete[] vector;
		}

		void resize(){
			Point *newVector = new Point[size + defaultSize];
			for (int i = 0; i < size; i++)
				newVector[i] = vector[i];
			destroyMe();
			defaultSize *= 2;
			vector = newVector;
		}

	public:
		ListOfPoints(){
			defaultSize = 4;
			size = 0;
			vector = new Point[defaultSize];
		}

		bool contain(const Point& element) const{
			for (int i = 0; i < size; i++)
				if (vector[i].equal(element))
					return true;
			return false;
		}

		virtual void add(const Point& element){
			if (defaultSize == size)
				resize();
			vector[size] = element;
			size += 1;
		}

		 void remove(int index){
			 if (index >= size)
				 return;
			 for (int i = index; i < size - 1; i++)
				 vector[i] = vector[i + 1];
			 size--;
		}

		int getSize() const{
			return size;
		}
		Point& getElement(int index) const{
			if (index <= size)
				return vector[index];
			throw invalid_argument("intex out of bound");
		}

		~ListOfPoints(){
			destroyMe();
		}

	private:

};

class Figure{
public:
	virtual double perimeter() const = 0;
	virtual double area() const = 0;
};


class Polygon : public ListOfPoints, public Figure{
public:
	Polygon() :ListOfPoints(){}
	double perimeter() const {
		double result = 0;
		for (int i = 0; i < size - 1; i++)
			result += sqrt((vector[i].getX() - vector[i + 1].getX())*(vector[i].getX() - vector[i + 1].getX()) +
			(vector[i].getY() - vector[i + 1].getY())*(vector[i].getY() - vector[i + 1].getY()));
		return result;
	}

	double area() const{
		double result = 0; 
		int j = size - 1;

		for (int i = 0; i<size; i++)
		{
			result = result + (vector[j].getX() + vector[i].getX()) * (vector[j].getY() - vector[i].getY());
			j = i; 
		}
		return result / 2;
	}

	~Polygon(){
		
	}
};

class Circle : public Figure
{
	int r;
public:
	Circle(int r){
		this->r = r;
	}

	double perimeter() const{
		return  2 * 3.14 * r;
	}
	double area() const{
		return r*r*3.14;;
	}

private:

};

void print(Figure* figure){
	cout << "Perimeter: " << figure->perimeter()<< endl;
	cout << "Area: " << figure->area() << endl;
	cout << endl;
}

int main(){
	
	Polygon polygon;
	polygon.add(Point(4, 6));
	polygon.add(Point(4, -4));
	polygon.add(Point(8, -4));
	polygon.add(Point(8, -8));
	polygon.add(Point(-4, -8));
	polygon.add(Point(-4, 6));

	Circle cr1(1);

	print(&polygon);
	print(&cr1);


	system("PAUSE");
	return 0;
}



#include<iostream>
#include<cmath>
using namespace std;
	class Bag
	{
	protected:
		int *vector;
		int defaultSize;
		int size;

	private:
		void destroyMe(){
			delete[] vector;
		}

		void resize(){
			int *newVector = new int[size + defaultSize];
			for (int i = 0; i < size; i++)
				newVector[i] = vector[i];
			destroyMe();
			defaultSize *= 2;
			vector = newVector;
		}

		int count(int element) const{
			int result = 0;
			for (int i = 0; i < size; i++)
				if (vector[i] == element)
					result++;
			return result;
		}

	public:
		Bag(){
			defaultSize = 4;
			size = 0;
			vector = new int[defaultSize];
		}

		bool contain(int element) const{
			for (int i = 0; i < size; i++)
				if (vector[i] == element)
					return true;
			return false;
		}

		virtual void add(int element){
			if (defaultSize == size)
				resize();
			vector[size] = element;
			size += 1;
		}

		virtual void remove(int element){ //remove all elements equal to "element" 
			for (int i = 0; i < size; i++)
			{
				if (vector[i] == element){
					for (int j = i; j < size - 1; j++)
						vector[j] = vector[j + 1];
					size--;
					i--;
				}
			}
		}

		virtual void unionVec(const Bag& other) const{
			cout << "{ ";
			for (int i = 0; i < size; i++)
				cout << vector[i] << " ";
			for (int i = 0; i < other.getSize(); i++)
				cout << other.getElement(i) << " ";
			cout << " }" << endl;
		}

		

		virtual void intersect(const Bag& other){
			cout << "{ ";
			int* arr = new int[size];
			int arrSize = 0;

			for (int i = 0; i < size; i++)
			{
				bool flag = false;
				int minOcc = (int)fmin(count(vector[i]), other.count(vector[i]));
				for (int j = 0; j < arrSize && !flag; j++)
					if (arr[j] == vector[i])
						flag = true;

				if (!flag){
					for (int j = 0; j < minOcc; j++)
						cout << vector[i] << " ";
					arr[arrSize] = vector[i];
					arrSize++;
				}
			}

			cout << " }" << endl;
			delete[] arr;
		}

		virtual void substract(const Bag& other){
			cout << "{ ";
			int* arr = new int[size];
			int arrSize = 0;

			for (int i = 0; i < size; i++)
			{
				bool flag = false;
				int occ = count(vector[i]) - other.contain(vector[i]);
				for (int j = 0; j < arrSize; j++)
					if (arr[j] == vector[i])
						flag = true;

				if (!flag){
					if (occ > 0)
						for (int j = 0; j < occ; j++)
							cout << vector[i] << " ";
					arr[arrSize] = vector[i];
					arrSize++;
				}
			}

			cout << " }" << endl;
			delete[] arr;
		}

		int getSize() const{
			return size;
		}
		int getElement(int index) const{
			if (index <= size)
				return vector[index];
			throw invalid_argument("intex out of bound");
		}


	
		~Bag(){
			destroyMe();
		}

	private:

	};

class Set : public Bag{

private:
	
public:

	Set() :Bag(){}

	void add(int element){
		if (contain(element))
			return;
		Bag::add(element);
	}

	void removeElement(int element){ //don't call base method because of the set's unique elements, so the loop breaks after first match 
		for (int i = 0; i < size; i++)
		{
			if (vector[i] == element){
				for (int j = i; j < size - 1; j++)
					vector[j] = vector[j + 1];
				size--;
				break;
			}
		}
	}

	void unionVec(const Set& other){
		cout << "{ ";
		int *arr = new int[size];
		int arrSize = 0;
		for (int i = 0; i < size; i++)
		{	
			cout << vector[i] << " ";
			if (other.contain(vector[i])){
				arr[i] = vector[i];
				arrSize++;
			}
		}
		for (int i = 0; i < other.getSize(); i++)
		{
			bool flag = false;
			for (int j = 0; j < arrSize && !flag; j++)
				if (arr[j] == other.getElement(i))
					flag = true;
			if (!flag)
				cout << other.getElement(i) << " ";
		}

		delete[] arr;
		cout << " }" << endl;
	}

	void intersect(const Set& other){
		cout << "{ ";
		for (int i = 0; i < size; i++)
			if (other.contain(vector[i]))
				cout << vector[i] << " ";
		cout << " }" << endl;
	}

	void substract(const Set& other){
		cout << "{ ";
		for (int i = 0; i < size; i++)
			if (!other.contain(vector[i]))
				cout << vector[i] << " ";
		cout << "}" << endl;
	}

	void intersect(){

	}
	

	~Set(){
		
	}
};



int main(){

	Bag bag;
	bag.add(1);
	bag.add(1);
	bag.add(1);
	bag.add(1);
	bag.add(5);

	Bag bag1;
	bag1.add(6);
	bag1.add(5);
	bag1.add(1);
	bag1.add(1);

	bag.intersect(bag1);
	system("PAUSE");
	return 0;
}

